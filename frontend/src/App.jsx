import { useState, useCallback, useMemo } from 'react';
import { Upload, FileText, Download, CheckCircle2, AlertCircle, Clock, Sparkles, Trophy, Target, Zap, PartyPopper, ChevronDown, ChevronRight, XCircle, Rocket } from 'lucide-react';
import confetti from 'canvas-confetti';


import './App.css'; 


if (typeof window.pdfjsLib !== 'undefined') {
  window.pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.js`;
}

/**
 * Extracts text content from a PDF File object using pdfjsLib (global).
 * @param {File} file - The uploaded PDF file.
 * @returns {Promise<string>} The extracted text content.
 */
const extractTextFromPDF = async (file) => {
  if (typeof window.pdfjsLib === 'undefined') {
    console.error("PDF.js library is not available globally (window.pdfjsLib).");
    return "Error: PDF processing library not loaded.";
  }
  
  try {
    const arrayBuffer = await file.arrayBuffer();
    // Use the global pdfjsLib
    const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    let fullText = '';

    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i); 
      const textContent = await page.getTextContent();
      const pageText = textContent.items.map(item => item.str).join(' ');
      fullText += pageText + '\n';
    }
    return fullText;
  } catch (error) {
    console.error("Error extracting text from PDF:", error);
    return `Error processing PDF: ${error.message}`;
  }
};


// =================================================================
// 2. Utility Functions
// =================================================================

/**
 * A placeholder analysis function that returns a fixed set of suggestions
 * for demonstration.
 * @param {string} resumeText - The text content of the uploaded resume.
 * @returns {Array<Object>} An array of suggestion objects.
 */
const analyzeResume = (resumeText) => {
    console.log("Analyzing resume text:", resumeText.substring(0, 50) + "...");

    // Basic check to ensure some text was provided
    if (!resumeText || resumeText.length < 50) {
        return [{
            id: 999,
            title: "Input Too Short",
            description: "Please paste or upload a full resume (min 50 characters) for proper analysis.",
            priority: "high",
            category: "Input Check",
            completed: false
        }];
    }

    // Return mock data (pure JS objects)
    return [
        {
            id: 1,
            title: "Quantify Achievements",
            description: "Replace 'Managed team' with 'Managed 5-person team, boosting productivity by 20%' in your experience section.",
            priority: "high",
            category: "Content & Impact",
            completed: false,
        },
        {
            id: 2,
            title: "Check Keywords",
            description: "Ensure 3-5 keywords from the target job description (e.g., 'Tailwind', 'REST API', 'Agile') are present.",
            priority: "high",
            category: "Targeting",
            completed: false,
        },
        {
            id: 3,
            title: "Font Consistency",
            description: "Verify that only one or two standard, clean fonts (e.g., Arial, Calibri) are used throughout.",
            priority: "low",
            category: "Formatting",
            completed: false,
        },
        {
            id: 4,
            title: "Remove 'References Available'",
            description: "This phrase is unnecessary; recruiters assume references are available. Use the space for content.",
            priority: "medium",
            category: "Brevity",
            completed: false,
        },
        {
            id: 5,
            title: "Summary/Objective Statement",
            description: "Include a concise 2-3 sentence summary tailored to the job you are applying for.",
            priority: "medium",
            category: "Content & Impact",
            completed: false,
        },
        {
            id: 6,
            title: "Contact Info Review",
            description: "Check that your email, phone, and LinkedIn/Portfolio links are correct and clickable.",
            priority: "high",
            category: "Basic Checks",
            completed: false,
        },
    ];
};

/**
 * Placeholder for PDF Generation, generates a text file instead.
 */
const generateChecklistFile = (suggestions, fileName) => {
    const list = suggestions.map(s => `- [${s.completed ? 'X' : ' '}] ${s.priority.toUpperCase()}: ${s.title}`).join('\n');
    const fileContent = `Resume Checklist for ${fileName || 'Your Resume'}\n\n=================================\n\n${list}\n\nGenerated by the Resume Coach App.`;
    
    const blob = new Blob([fileContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `Resume_Checklist_${fileName.replace(/\.pdf|\.txt/i, '') || 'Analysis'}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log(`Checklist TXT file generated and downloaded.`);
};


// =================================================================
// 3. Configuration & Helpers
// =================================================================

// CSS classes will handle the styling, but we keep the logic here for mapping
const PRIORITY_CLASSES = {
  high: 'priority-high',
  medium: 'priority-medium',
  low: 'priority-low',
};

const PRIORITY_ICONS = {
  high: AlertCircle,
  medium: Clock,
  low: CheckCircle2,
};

const CATEGORY_ICONS = {
  "Content & Impact": Trophy,
  "Targeting": Target,
  "Formatting": Zap,
  "Brevity": FileText,
  "Basic Checks": CheckCircle2,
  "Input Check": XCircle,
}

// Function to trigger a simple confetti effect
const triggerConfetti = () => {
  confetti({
    particleCount: 100,
    spread: 70,
    origin: { y: 0.6 }
  });
};


// Custom button component for reusability and aesthetics
const StyledButton = ({ onClick, children, className = '', disabled = false, icon: IconComponent }) => (
  <button
    onClick={onClick}
    disabled={disabled}
    className={`styled-button ${className} ${disabled ? 'disabled' : ''}`}
  >
    {IconComponent && <IconComponent className="icon" />}
    <span>{children}</span>
  </button>
);


// =================================================================
// 4. Main App Component
// =================================================================

export default function App() {
  const [resumeText, setResumeText] = useState('');
  const [suggestions, setSuggestions] = useState([]); 
  const [analyzed, setAnalyzed] = useState(false);
  const [fileName, setFileName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showCelebration, setShowCelebration] = useState(false);
  const [expandedCategory, setExpandedCategory] = useState(null);

  const handleFileChange = useCallback(async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setIsLoading(true);
    setFileName(file.name);
    setAnalyzed(false);
    setShowCelebration(false);

    try {
      let text = '';
      if (file.type === 'application/pdf') {
        text = await extractTextFromPDF(file);
      } else if (file.type === 'text/plain' || file.name.endsWith('.txt')) {
        text = await file.text();
      } else {
        console.error('Please upload a PDF or TXT file.');
        setResumeText('File upload failed: Please use a PDF or TXT file.');
        setSuggestions(analyzeResume('')); 
        setAnalyzed(true);
        setIsLoading(false);
        return;
      }
      
      setResumeText(text);
      const analysis = analyzeResume(text);
      setSuggestions(analysis);
      setAnalyzed(true);

    } catch (error) {
      console.error("File processing error:", error);
      setResumeText(`Error reading file: ${error.message}`);
      setSuggestions(analyzeResume('')); 
      setAnalyzed(true);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const handleAnalyzePaste = useCallback(() => {
    if (resumeText.length > 50) {
      const analysis = analyzeResume(resumeText);
      setSuggestions(analysis);
      setFileName('Pasted Content');
      setAnalyzed(true);
      setShowCelebration(false);
    } else {
      setSuggestions(analyzeResume('')); 
      setAnalyzed(true);
      setFileName('Pasted Content');
    }
  }, [resumeText]);

  const handleToggleSuggestion = useCallback((id) => {
    setSuggestions(prev => {
      const newSuggestions = prev.map(s => 
        s.id === id ? { ...s, completed: !s.completed } : s
      );

      const nonInputCheckSuggestions = newSuggestions.filter(s => s.category !== 'Input Check');
      const allCompleted = nonInputCheckSuggestions.length > 0 && nonInputCheckSuggestions.every(s => s.completed);

      if (allCompleted && !showCelebration) {
        setShowCelebration(true);
        triggerConfetti();
      } else if (!allCompleted && showCelebration) {
        setShowCelebration(false);
      }

      return newSuggestions;
    });
  }, [showCelebration]);

  const handleDownload = useCallback(() => {
    generateChecklistFile(suggestions, fileName);
  }, [suggestions, fileName]);

  const toggleCategory = useCallback((category) => {
    setExpandedCategory(prev => prev === category ? null : category);
  }, []);
  
  // Group suggestions by category
  const groupedSuggestions = useMemo(() => {
    const groups = suggestions.reduce((acc, suggestion) => {
      const category = suggestion.category || 'General';
      if (!acc[category]) {
        acc[category] = [];
      }
      acc[category].push(suggestion);
      return acc;
    }, {});
    
    return Object.keys(groups).sort((a, b) => {
        if (a === 'Input Check') return -1;
        if (b === 'Input Check') return 1;
        return a.localeCompare(b);
    }).map(category => ({
      category,
      items: groups[category],
      allCompleted: groups[category].every(item => item.completed)
    }));
  }, [suggestions]);

  // Calculate overall progress
  const totalSuggestions = useMemo(() => suggestions.filter(s => s.category !== 'Input Check').length, [suggestions]);
  const completedSuggestions = useMemo(() => suggestions.filter(s => s.completed && s.category !== 'Input Check').length, [suggestions]);
  const progressPercentage = totalSuggestions > 0 ? Math.round((completedSuggestions / totalSuggestions) * 100) : 0;
  
  return (
    <div className="app-container">
      <div className="content-wrapper">
        {/* Header */}
        <header className="app-header">
          <h1 className="main-title">
            <Rocket className="icon title-icon" /> Resume Coach
          </h1>
          <p className="subtitle">
            Get instant, actionable feedback and transform your resume.
          </p>
        </header>

        {/* Input Area */}
        <div className="input-area-card">
          <h2 className="section-title input-section-title">
            <Upload className="icon" /> 1. Upload or Paste Your Resume
          </h2>
          
          {/* File Input */}
          <div className="file-input-wrapper">
            <input 
              type="file" 
              id="file-upload" 
              accept=".pdf,.txt"
              className="hidden-input" 
              onChange={handleFileChange}
            />
            <label htmlFor="file-upload" className="file-upload-label">
                <StyledButton
                    icon={FileText}
                    className="button-upload"
                >
                    Choose PDF or TXT File
                </StyledButton>
            </label>
            {fileName && <p className="file-name-display">File: **{fileName}**</p>}
          </div>

          {/* Textarea Input */}
          <div className="textarea-relative-wrapper">
            <textarea
              className="resume-textarea"
              placeholder="Or paste your resume text here..."
              value={resumeText}
              onChange={(e) => setResumeText(e.target.value)}
              disabled={isLoading}
            />
            {isLoading && (
              <div className="loading-overlay">
                <div className="loading-spinner"></div>
                <p className="loading-text">Analyzing...</p>
              </div>
            )}
          </div>
          
          <div className="analyze-button-wrapper">
            <StyledButton
              onClick={handleAnalyzePaste}
              disabled={isLoading || resumeText.length < 10}
              className="button-analyze"
              icon={Sparkles}
            >
              Analyze Pasted Text
            </StyledButton>
          </div>
        </div>

        {/* Analysis Results & Checklist */}
        {analyzed && (
          <div className="results-card">
            <h2 className="section-title results-section-title">
              <CheckCircle2 className="icon" /> 2. Actionable Checklist
              <StyledButton
                onClick={handleDownload}
                className="button-download"
                icon={Download}
              >
                Download Checklist (.txt)
              </StyledButton>
            </h2>

            {/* Progress Bar */}
            <div className="progress-bar-wrapper">
              <div className="progress-header">
                <span className="progress-label">Progress:</span>
                <span className="progress-count">{completedSuggestions} / {totalSuggestions} Completed</span>
              </div>
              <div className="progress-bar-track">
                <div 
                  className="progress-bar-fill" 
                  style={{ width: `${progressPercentage}%` }}
                ></div>
              </div>
              <p className="progress-percentage">{progressPercentage}% Complete</p>
            </div>

            {/* Celebration Message */}
            {showCelebration && (
              <div className="celebration-message">
                <PartyPopper className="icon" />
                <span className="celebration-text">
                  Congratulations! All major suggestions are complete!
                </span>
                <p className="celebration-subtext">
                  Your resume is looking sharp. Time to apply!
                </p>
              </div>
            )}

            {/* Suggestions by Category */}
            <div className="suggestions-list-container">
              {groupedSuggestions.map(({ category, items, allCompleted }) => {
                const CategoryIcon = CATEGORY_ICONS[category] || ChevronRight;
                const isExpanded = expandedCategory === category;
                const totalItems = items.length;
                const completedItems = items.filter(i => i.completed).length;

                return (
                  <div key={category} className="category-group">
                    <button
                      className={`category-header ${allCompleted ? 'category-completed' : ''}`}
                      onClick={() => toggleCategory(category)}
                    >
                      <div className="header-content">
                        <CategoryIcon className="icon" />
                        <span>{category} ({completedItems}/{totalItems})</span>
                      </div>
                      {isExpanded ? <ChevronDown className="icon toggle-icon expanded" /> : <ChevronRight className="icon toggle-icon" />}
                    </button>

                    <div 
                      className={`suggestions-list ${isExpanded ? 'expanded' : ''}`} 
                    >
                      <ul className="suggestions-ul">
                        {items.map((suggestion) => {
                          const PriorityIcon = PRIORITY_ICONS[suggestion.priority];
                          
                          return (
                            <li
                              key={suggestion.id}
                              className={`suggestion-item ${suggestion.completed ? 'completed' : ''}`}
                            >
                              <input
                                type="checkbox"
                                checked={suggestion.completed}
                                onChange={() => handleToggleSuggestion(suggestion.id)}
                                className="suggestion-checkbox"
                              />
                              <div className="suggestion-details">
                                <p className={`suggestion-title ${suggestion.completed ? 'line-through' : ''}`}>
                                  {suggestion.title}
                                </p>
                                <p className="suggestion-description">
                                  {suggestion.description}
                                </p>
                              </div>
                              <div className={`priority-tag ${PRIORITY_CLASSES[suggestion.priority]}`}>
                                <PriorityIcon className="icon" />
                                {suggestion.priority.toUpperCase()}
                              </div>
                            </li>
                          );
                        })}
                      </ul>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}